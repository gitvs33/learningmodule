<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Optimizer Explainer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        .info-card {
            background: white;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0; /* slate-200 */
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
        }
        .active-btn {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            font-weight: 600;
        }
        #loss-canvas {
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(79, 70, 229, 0.2), transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(79, 70, 229, 0.15), transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(79, 70, 229, 0.1), transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(79, 70, 229, 0.05), transparent 80%);
            cursor: crosshair;
        }
    </style>
</head>
<body class="text-slate-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-900">Visualizing Optimizers</h1>
            <p class="mt-4 text-lg text-slate-600 max-w-3xl mx-auto">The "Manager" that guides the neural network to the best solution.</p>
        </header>

        <section class="info-card p-4 md:p-6">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Visualization -->
                <div class="lg:col-span-2">
                    <h2 class="text-xl font-bold mb-2">The Loss Landscape</h2>
                    <p class="text-sm text-slate-500 mb-4">The goal is to find the lowest point (minimum loss). Click to set a starting point.</p>
                    <div class="aspect-square w-full relative">
                        <canvas id="loss-canvas" class="w-full h-full rounded-lg border border-slate-200"></canvas>
                    </div>
                </div>

                <!-- Controls and Info -->
                <div class="flex flex-col">
                    <h2 class="text-xl font-bold mb-4">Controls</h2>
                    <div class="mb-6">
                        <label class="font-medium mb-2 block">1. Choose an Optimizer:</label>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <button class="optimizer-btn flex-1 py-2 px-3 rounded-md transition active-btn" data-optimizer="adam">Adam</button>
                            <button class="optimizer-btn flex-1 py-2 px-3 rounded-md transition bg-white border" data-optimizer="sgd">SGD</button>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <label class="font-medium mb-2 block">2. Start Training:</label>
                        <button id="start-btn" class="w-full bg-green-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-700 transition shadow-md">Start</button>
                        <button id="reset-btn" class="w-full mt-2 bg-slate-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-slate-700 transition">Reset</button>
                    </div>

                    <hr class="my-4">

                    <div id="info-panel" class="flex-grow">
                        <h3 id="info-title" class="text-2xl font-bold mb-2"></h3>
                        <p id="info-description" class="text-slate-600 mb-4 text-sm"></p>
                        <div class="bg-slate-50 border border-slate-200 rounded-lg p-3">
                            <h4 class="font-semibold text-slate-700 mb-2">Key Characteristics:</h4>
                            <ul id="info-pros" class="list-disc list-inside space-y-1 text-sm text-slate-600"></ul>
                        </div>
                    </div>
                     <div class="mt-4 text-sm text-slate-500">
                        <p>Epoch: <span id="epoch-counter" class="font-mono font-semibold">0</span></p>
                    </div>
                </div>
            </div>
        </section>

        <!-- NEW Explanation Section -->
        <section class="info-card p-6 md:p-8 mt-8">
            <h3 class="text-2xl font-bold mb-4 text-center">Why is the path wiggly vs. straight?</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-center">
                <div>
                    <h4 class="text-xl font-semibold text-slate-800 mb-2">SGD: The Straight Path</h4>
                    <p class="text-slate-600">
                        SGD is "memory-less". At every step, it only looks at the current steepest downhill direction and takes a small step. In this simple bowl-shaped landscape, the steepest direction is always directly toward the center, resulting in a predictable, straight-line path.
                    </p>
                </div>
                <div>
                    <h4 class="text-xl font-semibold text-slate-800 mb-2">Adam: The "Wiggly" Path</h4>
                    <p class="text-slate-600">
                        The wiggle is caused by <strong>momentum</strong>. Adam has a "memory" of the direction it was just traveling. Like a ball rolling downhill, it builds up speed and its momentum can carry it slightly past the most direct path, causing it to "overshoot" and then correct its course. This wiggle is a sign of the momentum that helps Adam move faster and avoid getting stuck in complex, real-world loss landscapes.
                    </p>
                </div>
            </div>
        </section>
        
        <section class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
            <div class="info-card p-6">
                <h3 class="text-xl font-bold mb-3">What is an Optimizer's Function?</h3>
                <p class="text-slate-600">
                    After the loss function calculates *how wrong* the model is, and backpropagation figures out *which weights are to blame* (the gradients), the optimizer's job is to intelligently update those weights. It decides the direction and the size of the step to take towards a better solution, aiming to minimize the loss.
                </p>
            </div>
            <div class="info-card p-6">
                <h3 class="text-xl font-bold mb-3">How Does it Work?</h3>
                <p class="text-slate-600">
                   It uses the gradient information to navigate the "loss landscape". A steep gradient means the model is very wrong, so the optimizer might take a bigger step. A shallow gradient suggests it's close to a good solution, so it takes a smaller, more careful step. Different optimizers (like Adam vs. SGD) use different strategies for this navigation.
                </p>
            </div>
        </section>

    </div>

    <script>
        const canvas = document.getElementById('loss-canvas');
        const ctx = canvas.getContext('2d');
        
        const info = {
            adam: {
                title: "Adam",
                description: "An adaptive and popular optimizer. It combines the ideas of momentum (keeping track of past gradients) and adaptive learning rates (adjusting the step size for each parameter).",
                pros: [
                    "Converges quickly due to momentum.",
                    "Effective and requires little tuning.",
                    "Adapts the learning rate automatically."
                ]
            },
            sgd: {
                title: "SGD",
                description: "Stochastic Gradient Descent is the simplest optimizer. It updates weights by taking small, consistent steps in the direction of the negative gradient.",
                pros: [
                    "Computationally simple and fast per step.",
                    "Follows a direct path in simple landscapes.",
                    "Can be slow or get stuck in complex landscapes."
                ]
            }
        };

        let width, height;
        let currentOptimizer = 'adam';
        let point = { x: 80, y: 80 };
        let path = [];
        let animationFrameId;
        let epochCounter = 0;

        // Optimizer state
        let m = { x: 0, y: 0 }; // Adam momentum
        let v = { x: 0, y: 0 }; // Adam RMSprop

        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const epochDisplay = document.getElementById('epoch-counter');

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            width = canvas.width;
            height = canvas.height;
            ctx.scale(dpr, dpr);
            draw();
        }

        // The "loss function" is defined by the background gradient circles
        // The center is the minimum. The gradient is just the vector towards the center.
        function getGradient(p) {
            const centerX = width / 2;
            const centerY = height / 2;
            return {
                dx: (p.x - centerX) / (width / 2),
                dy: (p.y - centerY) / (height / 2)
            };
        }

        function updatePoint() {
            const grad = getGradient(point);
            let step;

            if (currentOptimizer === 'sgd') {
                const lr = 15; // Learning rate
                step = {
                    dx: lr * grad.dx,
                    dy: lr * grad.dy
                };
            } else if (currentOptimizer === 'adam') {
                const lr = 20;
                const beta1 = 0.9;
                const beta2 = 0.999;
                const epsilon = 1e-8;

                m.x = beta1 * m.x + (1 - beta1) * grad.dx;
                m.y = beta1 * m.y + (1 - beta1) * grad.dy;

                v.x = beta2 * v.x + (1 - beta2) * Math.pow(grad.dx, 2);
                v.y = beta2 * v.y + (1 - beta2) * Math.pow(grad.dy, 2);
                
                const m_hat_x = m.x / (1 - Math.pow(beta1, epochCounter + 1));
                const m_hat_y = m.y / (1 - Math.pow(beta1, epochCounter + 1));

                const v_hat_x = v.x / (1 - Math.pow(beta2, epochCounter + 1));
                const v_hat_y = v.y / (1 - Math.pow(beta2, epochCounter + 1));

                step = {
                    dx: lr * m_hat_x / (Math.sqrt(v_hat_x) + epsilon),
                    dy: lr * m_hat_y / (Math.sqrt(v_hat_y) + epsilon)
                };
            }

            point.x -= step.dx;
            point.y -= step.dy;
        }

        function draw() {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
            
            // Draw path
            if (path.length > 1) {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)'; // red-500
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw current point
            ctx.beginPath();
            ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#ef4444'; // red-500
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function animate() {
            if (epochCounter >= 100) {
                stopAnimation();
                return;
            }
            path.push({ ...point });
            updatePoint();
            draw();
            epochCounter++;
            epochDisplay.textContent = epochCounter;
            animationFrameId = requestAnimationFrame(animate);
        }

        function stopAnimation() {
            cancelAnimationFrame(animationFrameId);
            startBtn.disabled = false;
        }

        function reset() {
            stopAnimation();
            epochCounter = 0;
            epochDisplay.textContent = 0;
            path = [];
            m = { x: 0, y: 0 };
            v = { x: 0, y: 0 };
            draw();
        }

        function updateInfoPanel(optimizerName) {
            const data = info[optimizerName];
            document.getElementById('info-title').textContent = data.title;
            document.getElementById('info-description').textContent = data.description;
            const prosList = document.getElementById('info-pros');
            prosList.innerHTML = '';
            data.pros.forEach(pro => {
                const li = document.createElement('li');
                li.textContent = pro;
                prosList.appendChild(li);
            });
        }
        
        // Event Listeners
        document.querySelectorAll('.optimizer-btn').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.optimizer-btn').forEach(btn => {
                    btn.classList.remove('active-btn');
                    btn.classList.add('bg-white', 'border');
                });
                button.classList.add('active-btn');
                button.classList.remove('bg-white', 'border');
                currentOptimizer = button.dataset.optimizer;
                updateInfoPanel(currentOptimizer);
                reset();
            });
        });

        startBtn.addEventListener('click', () => {
            reset();
            startBtn.disabled = true;
            animate();
        });

        resetBtn.addEventListener('click', () => {
            point = { x: 80, y: 80 }; // Reset to default start
            reset();
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            point = { x, y };
            reset();
            draw();
        });

        window.addEventListener('resize', resizeCanvas);
        
        // Initial setup
        window.onload = () => {
            resizeCanvas();
            updateInfoPanel(currentOptimizer);
        };

    </script>
</body>
</html>
