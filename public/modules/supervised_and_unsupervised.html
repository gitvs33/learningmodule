<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Fundamentals: Supervised vs. Unsupervised</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            text-align: center;
            background-color: #f0f2f5;
            color: #1c1e21;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        .main-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .canvas-container {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
            padding: 25px;
            width: 420px;
            display: flex;
            flex-direction: column;
        }
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 15px auto;
            border-radius: 8px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-top: auto; /* Pushes button to the bottom */
        }
        button:hover {
            background-color: #0056b3;
        }
        button:active {
            transform: scale(0.98);
        }
        .description {
            max-width: 400px;
            margin: 0 auto 20px auto;
            color: #555;
            line-height: 1.6;
            text-align: left;
            font-size: 15px;
        }
        .description strong {
            color: #333;
        }
        .description h3 {
            font-size: 16px;
            color: #007bff;
            margin-bottom: 5px;
            margin-top: 10px;
        }
        .description ul {
            padding-left: 20px;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <h1>Supervised vs. Unsupervised Learning</h1>

    <div class="main-container">

        <!-- SUPERVISED LEARNING VISUALIZATION -->
        <div class="canvas-container">
            <h2>Supervised Learning (Classification) ü§ñ</h2>
            <div class="description">
                <h3>The Analogy: Learning with Flashcards</h3>
                <p>
                    Imagine teaching a child with flashcards. You show them a picture of a cat and say "cat". You show a dog and say "dog". You are giving them <strong>labeled examples</strong>.
                </p>
                <h3>The Mission:</h3>
                <p>
                   When you click "Train", the model studies these examples to learn the difference. The goal is to create a rule (the black line) so it can correctly identify a <strong>new, unseen</strong> shape.
                </p>
                <h3>When Do You Use This?</h3>
                <p>You use this when you have historical data with known outcomes and want to predict that outcome for new data. Examples include:</p>
                <ul>
                    <li><strong>Spam Detection:</strong> Using past emails labeled as 'spam' or 'not spam'.</li>
                    <li><strong>Image Recognition:</strong> Identifying tumors in scans that doctors have already labeled.</li>
                    <li><strong>Price Prediction:</strong> Forecasting house prices based on past sales data.</li>
                </ul>
            </div>
            <canvas id="supervisedCanvas" width="400" height="300"></canvas>
            <button id="trainSupervisedBtn">Train Model</button>
        </div>

        <!-- UNSUPERVISED LEARNING VISUALIZATION -->
        <div class="canvas-container">
            <h2>Unsupervised Learning (Clustering) üßê</h2>
             <div class="description">
                <h3>The Analogy: Sorting Laundry</h3>
                <p>
                    Imagine being given a giant pile of laundry with socks, shirts, and pants all mixed up. No one tells you what's what. Instinctively, you start making piles: one for socks, one for shirts, etc. You create groups based on similarity.
                </p>
                 <h3>The Mission:</h3>
                 <p>
                    When you click "Find Clusters", the model examines the messy data and <strong>finds patterns on its own</strong>, grouping similar items together into colored clusters.
                </p>
                 <h3>When Do You Use This?</h3>
                 <p>You use this when you don't have labeled data and want to discover hidden structures or relationships. Examples include:</p>
                 <ul>
                    <li><strong>Customer Segments:</strong> Grouping customers by purchasing behavior for marketing campaigns.</li>
                    <li><strong>Anomaly Detection:</strong> Identifying unusual credit card transactions that don't fit any normal pattern.</li>
                    <li><strong>Topic Modeling:</strong> Grouping news articles into topics like 'sports', 'politics', or 'tech'.</li>
                 </ul>
            </div>
            <canvas id="unsupervisedCanvas" width="400" height="300"></canvas>
            <button id="clusterUnsupervisedBtn">Find Clusters</button>
        </div>

    </div>

    <script>
        /*************************************/
        /* SUPERVISED LEARNING SCRIPT        */
        /*************************************/
        const supervisedCanvas = document.getElementById('supervisedCanvas');
        const ctxSupervised = supervisedCanvas.getContext('2d');
        const trainSupervisedBtn = document.getElementById('trainSupervisedBtn');

        const supervisedPoints = [
            // Class 0 (Blue Squares)
            { x: 50, y: 60, label: 0 }, { x: 80, y: 100, label: 0 },
            { x: 120, y: 80, label: 0 }, { x: 70, y: 150, label: 0 },
            { x: 150, y: 130, label: 0 },
            // Class 1 (Red Circles)
            { x: 250, y: 180, label: 1 }, { x: 300, y: 250, label: 1 },
            { x: 350, y: 200, label: 1 }, { x: 280, y: 160, label: 1 },
            { x: 320, y: 220, label: 1 }
        ];

        function drawSupervisedPoints() {
            ctxSupervised.clearRect(0, 0, supervisedCanvas.width, supervisedCanvas.height);
            supervisedPoints.forEach(p => {
                ctxSupervised.beginPath();
                if (p.label === 0) {
                    ctxSupervised.fillStyle = 'rgba(0, 123, 255, 0.8)'; // Blue
                    ctxSupervised.fillRect(p.x - 5, p.y - 5, 10, 10);
                } else {
                    ctxSupervised.fillStyle = 'rgba(220, 53, 69, 0.8)'; // Red
                    ctxSupervised.arc(p.x, p.y, 6, 0, 2 * Math.PI);
                    ctxSupervised.fill();
                }
            });
        }

        trainSupervisedBtn.onclick = () => {
            drawSupervisedPoints(); // Redraw points to clear previous lines
            // Animate the decision boundary line
            ctxSupervised.strokeStyle = 'black';
            ctxSupervised.lineWidth = 3;
            ctxSupervised.beginPath();
            ctxSupervised.moveTo(0, 200);
            let targetX = 400, targetY = 100;
            let currentX = 0, currentY = 200;
            let animation = setInterval(() => {
                currentX += 8;
                currentY -= 2;
                ctxSupervised.lineTo(currentX, currentY);
                ctxSupervised.stroke();
                if (currentX >= targetX) {
                    clearInterval(animation);
                }
            }, 20);
        };
        
        // We need a single window.onload at the end of the script
        function initializeVisuals() {
            drawSupervisedPoints();
            drawUnsupervisedPoints();
        }


        /*************************************/
        /* UNSUPERVISED LEARNING SCRIPT      */
        /*************************************/
        const unsupervisedCanvas = document.getElementById('unsupervisedCanvas');
        const ctxUnsupervised = unsupervisedCanvas.getContext('2d');
        const clusterUnsupervisedBtn = document.getElementById('clusterUnsupervisedBtn');

        const unsupervisedPoints = [
            // Cluster 1
            { x: 60, y: 70 }, { x: 90, y: 110 }, { x: 130, y: 90 }, { x: 80, y: 160 },
            // Cluster 2
            { x: 280, y: 100 }, { x: 330, y: 80 }, { x: 300, y: 140 },
            // Cluster 3
            { x: 150, y: 250 }, { x: 220, y: 220 }, { x: 190, y: 280 }, { x: 250, y: 260 }
        ];

        function drawUnsupervisedPoints(assignments = {}) {
            ctxUnsupervised.clearRect(0, 0, unsupervisedCanvas.width, unsupervisedCanvas.height);
            const colors = ['#ffc107', '#28a745', '#dc3545']; // Yellow, Green, Red for clusters
            
            unsupervisedPoints.forEach((p, index) => {
                const clusterIndex = assignments[index];
                ctxUnsupervised.fillStyle = (clusterIndex !== undefined) ? colors[clusterIndex] : 'grey';
                ctxUnsupervised.beginPath();
                ctxUnsupervised.arc(p.x, p.y, 6, 0, 2 * Math.PI);
                ctxUnsupervised.fill();
            });
        }

        clusterUnsupervisedBtn.onclick = () => {
            // A simplified K-Means clustering visualization
            let centroids = [
                { x: 50, y: 50, color: '#ffc107' },
                { x: 350, y: 50, color: '#28a745' },
                { x: 200, y: 200, color: '#dc3545' }
            ];
            
            let assignments = {};
            
            // Re-draw initial state before animating
            drawUnsupervisedPoints();

            // Step 1: Assign points to nearest centroid
            setTimeout(() => {
                 unsupervisedPoints.forEach((p, index) => {
                    let minDist = Infinity;
                    let bestCluster = -1;
                    centroids.forEach((c, cIndex) => {
                        const dist = Math.sqrt((p.x - c.x)**2 + (p.y - c.y)**2);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = cIndex;
                        }
                    });
                    assignments[index] = bestCluster;
                });
                drawUnsupervisedPoints(assignments);
            }, 500); // Wait 0.5s before showing assignments
        };

        // Initial draw on window load
        window.onload = initializeVisuals;
    </script>

</body>
</html>
